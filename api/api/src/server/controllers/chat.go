package controllers

import (
	"context"
	"errors"
	"time"

	"bitbucket.org/mobinteg/ajuda-mais/src/chat"
	"bitbucket.org/mobinteg/ajuda-mais/src/firebase"
	"bitbucket.org/mobinteg/ajuda-mais/src/util/gobutil"
	"bitbucket.org/mobinteg/ajuda-mais/src/util/httputil"
	"bitbucket.org/mobinteg/ajuda-mais/src/util/stringutil"
	"firebase.google.com/go/v4/messaging"
	"github.com/gin-gonic/gin"
	"github.com/go-redis/redis/v8"
	"github.com/google/uuid"
	"gorm.io/gorm"
)

type ChatController struct {
	db         *gorm.DB
	chatClient *chat.Chat
	tasks      scheduler
	rdb        *redis.Client
	msgCodec   *gobutil.GobCodec[messaging.Message]
}

type GenerateChatTokenParams struct {
	// WithUser is the ID of the second user in the chatroom, the first being
	// the one identified by the authentication token.
	WithUser string `form:"withUser" binding:"required,uuid"`
}

type ChatToken struct {
	Value string `json:"value"`
}

// Generate a short-lived token used to authenticate the WebSocket connection.
//
//	@Summary	Generate a short-lived, single-use token, used to authenticate the WebSocket connection
//	@Tags		chat
//	@Produce	json
//	@Security	OIDCToken
//	@Security	AuthHeader
//	@Param		params			query		GenerateChatTokenParams	true	"Params"
//	@Success	201				{object}	ChatToken
//	@Failure	400,401,403,500	{object}	middleware.ApiError
//	@Router		/chat/token [get]
func (c *ChatController) GenerateToken(ctx *gin.Context) (ChatToken, error) {
	user, err := tokenUser(ctx, c.db)
	if err != nil {
		return ChatToken{}, err
	}

	var params GenerateChatTokenParams
	if err := ctx.ShouldBindQuery(&params); err != nil {
		return ChatToken{}, httputil.NewError(httputil.BadRequest, err)
	}

	token, err := c.chatClient.NewToken(
		ctx,
		roomID(user.ID.String(), params.WithUser),
		user.ID.String(),
	)

	return ChatToken{token}, err
}

type SubscribeParams struct {
	// Token is the temporary authentication token.
	Token string `form:"token" binding:"required"`
}

// Subscribe upgrades the connection to a WebSocket and transmits to the client
// messages published to the room identified by the given token.
//
//	@Summary		Connect to a WebSocket to subscribe to a chat room
//	@Description	The chat room is identified by the given token, which is generated by the `/chat/token` method.
//	@Description	The connection expects control frames (ping/pong) to be initiated by the client.
//	@Tags			chat
//	@Produce		json
//	@Param			params	query	SubscribeParams	true	"Filters"
//	@Success		101
//	@Failure		400,401,500	{object}	middleware.ApiError
//	@Router			/chat/ws  [get]
func (c *ChatController) Subscribe(ctx *gin.Context) {
	var params SubscribeParams
	if err := ctx.ShouldBindQuery(&params); err != nil {
		ctx.Error(httputil.NewError(httputil.BadRequest, err))
		return
	}

	roomID, clientID, err := c.chatClient.RedeemToken(ctx, params.Token)
	if err != nil {
		ctx.Error(httputil.NewErrorMsg(
			httputil.BadRequest,
			"the provided token is invalid or has expired",
		))
		return
	}

	if err := c.chatClient.WSHandler(
		ctx.Writer, ctx.Request,
		roomID, clientID,
	); err != nil {
		ctx.Error(err)
	}
}

type ListMessageFilters struct {
	Pagination
	// WithUser is the ID of the second user in the chatroom, the first being
	// the one identified by the authentication token.
	WithUser string `form:"withUser" binding:"required,uuid"`
}

// ListMessages returns all sent messages between two users.
//
//	@Summary	List all messages in room
//	@Tags		chat
//	@Produce	json
//	@Security	OIDCToken
//	@Security	AuthHeader
//	@Param		filters		query		ListMessageFilters	true	"Filters"
//	@Success	200			{array}		chat.Message
//	@Failure	400,401,500	{object}	middleware.ApiError
//	@Router		/chat  [get]
func (c *ChatController) ListMessages(
	filters ListMessageFilters,
	ctx *gin.Context,
) ([]chat.Message, error) {
	user, err := tokenUser(ctx, c.db)
	if err != nil {
		return nil, err
	}

	c.unflagNotified(user.ID.String(), filters.WithUser)

	return c.chatClient.Messages(ctx,
		roomID(user.ID.String(), filters.WithUser),
		int64(filters.Limit),
		int64(filters.Offset),
	)
}

type PostMessageParams struct {
	Text   string `json:"text" binding:"required"`
	ToUser string `json:"toUser" binding:"required,uuid"`
}

// scheduleCancelationNotification schedules a task to notify the given user
// that the task was canceled.
func (c *ChatController) scheduleChatMessageNotification(
	targetID string,
	fromID string,
	fromName string,
	msg chat.Message,
) {
	if c.alreadyNotified(targetID, fromID) {
		return
	} else {
		c.flagNotified(targetID, fromID)
	}
	scheduleNotification(firebase.ChatMsgMessage(
		firebase.ChatMsgMessageConfig{
			FromID:   msg.From,
			FromName: fromName,
			Msg:      stringutil.Ellipsis(msg.Text, 100),
		},
	), targetID, c.msgCodec, c.db, c.tasks)
}

// PostMessage posts a message in a chat room.
//
//	@Summary		Post a chat message
//	@Description	The message is broadcast to the other subscribers of the room
//	@Tags			chat
//	@Produce		json
//	@Security		OIDCToken
//	@Security		AuthHeader
//	@Param			params		body		PostMessageParams	true	"Params"
//	@Success		201			{object}	chat.Message
//	@Failure		400,401,500	{object}	middleware.ApiError
//	@Router			/chat [post]
func (c *ChatController) PostMessage(
	params PostMessageParams,
	ctx *gin.Context,
) (chat.Message, error) {
	user, err := tokenUser(ctx, c.db)
	if err != nil {
		return chat.Message{}, err
	}

	timestamp := time.Now().UnixMilli()
	msg := chat.Message{
		ID:        uuid.New().String(),
		Timestamp: timestamp,
		Type:      "text",
		Room:      roomID(user.ID.String(), params.ToUser),
		From:      user.ID.String(),
		Text:      params.Text,
	}

	err = c.chatClient.Post(ctx, msg)
	if err != nil {
		if errors.Is(err, chat.ErrPostRateExceeded) {
			return chat.Message{},
				httputil.NewError(httputil.MessagePostRateExceeded, err)
		}
		return msg, err
	}

	if !c.chatClient.HasSubscriber(ctx, msg.Room, params.ToUser) {
		c.scheduleChatMessageNotification(params.ToUser, user.ID.String(),
			user.Name, msg)
	}

	return msg, nil
}

func roomID(userID1 string, userID2 string) string {
	if userID1 > userID2 {
		t := userID1
		userID1 = userID2
		userID2 = t
	}

	return "room:" + userID1[:13] + ":" + userID2[:13]
}

func notifiedFlagKey(targetID, fromID string) string {
	return "notified:" + targetID + ":" + fromID
}

// alreadyNotified returns whether the target is flagged as notified of messages
// from fromID.
//
// This is used to avoid spamming the target with notifications.
func (c *ChatController) alreadyNotified(targetID, fromID string) bool {
	res := c.rdb.Get(context.Background(), notifiedFlagKey(targetID, fromID))
	return res.Err() == nil && res.Val() == "true"
}

// flagNotified flags the target as been notified of new messages from fromID.
func (c *ChatController) flagNotified(targetID, fromID string) {
	c.rdb.SetEX(context.Background(),
		notifiedFlagKey(targetID, fromID), "true", time.Hour)
}

// unflagNotified removes the notified flag of the target.
func (c *ChatController) unflagNotified(targetID, fromID string) {
	c.rdb.Del(context.Background(), notifiedFlagKey(targetID, fromID))
}
